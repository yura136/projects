/* Замыкания - closures*/
/* С каждой функцией связана цепочка областей видимости переменных
   Замыкание - это функция вместе с этой цепочкой.
   Т.е. сторого говоря каждую функцию можно назвать замыканием. */


/* Лексическая область видимости (lexical scoping) - при выполнении функции используется та область видимости переменных,
которая существовала при объявление этой функции*/

/*Короче замыкания, это функция объявленная внутри функции, благодаря которой локальные переменные внутри старшей функции 
не сбрасываются после завершения работы этой функции, а остаются при повторном вызове.
Замыканиями они называются потому, что младшая функция их замыкает внутри старшей. А почему так происходит, х.з. видимо фича языка.﻿*/

/* Когда интепретатор выполняет функцию func(), он создает объект, который будет содержать все локальные переменные 
для этого вызова функции (в нашем случае переменная i).
   Любые функции, которые мы определяем внутри функции (в нашем случае возвращаемая фукнция) сохраняют ссылку на 
этот объект с локальными переменными, и этот объект существует в том случае если есть функции которые на него ссылаются.
	Если бы было:  var func = function() {var i = 10;}, т.е. внутри не было функций которые на него ссылаются, т.е. нету 
больше никакого способа получить доступ к переменной i, у интерпретатора нет ни какого повода, чтобы хранить эту переменную, 
после выполнения функции. 
	И поэтому объект содержащий эту функцию будет уничтожен сразу же после выполнения функции  - GARBAGE COLLECTION*/

var func = function() {
	var i = 10;
	return function() {
		return i;   // Есть ссылка на объект, т.е. после выполнения функции func(), объект с переменной i, не уничтожится
	}
};

/* var myFunc = func(); - присваиваем переменной функцию, возвращаемую из функции func()*/

var anotherFunc = function() {
	var i = 20;
	// console.log(myFunc());
	console.log(func()()); //Попытка вызвать функцию, которая возращается из функции func(), выводим в консоль
	//  Выведет 10, из-за lexical scoping
};

anotherFunc();

// Пример замыкания, напишем счетчик
// Замыкание очень удобно создавать при помощи анонимных самовызывающихся функций
// Переменной counter присвоена функция, которая возращается из анонимной самовызывающейся функции
var counter = (function(){
	var count = 0;
	return function(num) {
		count = num !== undefined ? num : count;
		return count++;
	}
}()); // func(){}(); - самовызывающееся функция

// Фишка замыканий, т.е. функция не принимает никаких аргументов но выводит разные значения
// Т.е. замыкание как бы инкапсулирует переменную count (ее можно условной считать private), т.е. ее можно изменить только изнутри
console.log(counter()); //0
console.log(counter()); //1
console.log(counter()); //2
console.log(counter()); //3
console.log(counter()); //4
console.log(counter(0)); // сброс счетчика 0
console.log(counter()); //1
console.log(counter()); //2
console.log(counter(500)); //500
console.log(counter()); //501

// Второй способ написания счетчика
// Так как функция - это объект, то можем вызвать свойства объекта
var counter1 = function(num) {
	counter1.count = num !== undefined ? num : counter1.count; 
	return counter1.count++;
};

counter1.count = 0;
console.log("");
console.log(counter1()); // 0
console.log(counter1()); // 1 
console.log(counter1(0)); // 0
console.log(counter1(500)); // 500