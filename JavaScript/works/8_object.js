// Объект - набор свойств, которые предствляют собой пары (имя: значение)


/* Первый способ создания объекта, при помощи объектного литерала */
// Объектовый литерал (с точки зрения синтаксиса)
// Литерал - это один из способов создания объекта
/*
{
	name: "Yura",
	age: 20,
	gender: "male"
}
*/

// Присваиваем объект переменной 

var person = {
	name: "Yura",
	age: 28,
	gender: "male",
	sayHi: function() { // Если значения свойства функция, то такое свойство называют методом
		return "Hello!";
	}
}

// Обращение к свойствам (полям) объекта через переменную
// Выражение обращения (доступа) - Property Access Expression - для обращения к полям объекта (2 синтаксиса)
// Первый способ (синтаксис: выражение.идентификатор)
console.log(person.name); // Yura
console.log(person.age); // 28
console.log(person.gender); // male

// Второй способ (синтаксис: выражение[выражение])
// Благодаря тому, что можно подставлять в [] любое выражение, можно формировать эта имя свойства динамически
console.log(person["age"]); // 28

// Изменение свойств объекта
person.age = 25;
console.log(person["age"]); // 25

// Добавляем свойство к объекту
person.userID = 223335;
console.log(person.userID); // 223335

// Выводим весь объект в консоль
console.log(person); // {name: "Yura", age: 25, gender: "male", sayHi: ƒ, userID: 223335}

// В JavaScript нет никакой разницы между обычными свойствами и методами (функция как свойство)
console.log(person.sayHi()); // Hello!

/* Второй способ создания объекта при помощи конструктора и оператора new */
var object = new Object();
// Вешаем свойства на объект
object.property = "value";

/*  Третий способ, через статический метод create() класса Object (EcmaScript 5), он принимает первым параметром объект, 
который будет являться прототипом первого объекта */

var object1 = Object.create(null);
console.log(object1); // {} - null - если мы не хотим, чтобы новый объект наследовал какие-либо свойства

// Передадим какой-то объект (через литерал)
var object2 = Object.create({x: 10, y: 20});
// У меня явно не видит наследованные свойства, только при нажатии на стрелочку в консоли
console.log(object2); // {} x: 10, y: 20 - это не его собственные свойства, а свойства наследованные от прототипа
// Убеждаемя в этом
console.log(object2.hasOwnProperty("x")); // false, у нашего объекта нет свойства x

// Добавим такое свойство к объекту
object2.x = 30;
console.log(object2.hasOwnProperty("x")); // true, так как добавили

// Т.е в объекте как бы два свойства x
console.log(object2); // {x: 30} x: 10, y: 20
console.log(object2.x); // 30 - родное, а не наследованное от прототипа

// Удаляем свойства из объекта (унарный оператор delete)
delete object2.x; // Можно удалить только родные свойства, не наследованные. 
// Наследованные свойства можно удалить только напрямую у самого прототипа
console.log(object2); //  {} x: 10, y: 20

// Для проверки свойства в объекте есть бинарный оператор in
console.log("x" in object2); // true - вне зависимости, от того наследуемое оно или родное
console.log("z" in object2); // false

console.log(object2.z); // undefined - выражение обращения

// Оператор in различает отсутствующие свойства, и установленные в undifined вручную
console.log("z" in object2); // false, свойство отсутствует
object2.z = undefined; // Устанавливаем вручную
console.log("z" in object2); // true 
console.log(object2.z); // undefined


